/***************************************************************
 * Name:      qtwprogenerator.cpp
 * Purpose:   Code::Blocks plugin
 * Author:    Yorgos Pagles<y.pagles@gmail.com>
 * Copyright: (c) Yorgos Pagles
 * License:   GPL
 **************************************************************/
#ifndef __WXMSW__
#include <sys/utsname.h>
#endif
#include <wx/tokenzr.h>
#include <sdk.h>

#include "qtwprogenerator.h"

qtwProGenerator::qtwProGenerator(cbProject* project, wxString CompilerID, wxString* arguments)
        :m_Project(project),
        m_Arguments(arguments),
        m_Configuration(_T("")),
        m_GeneratingPro(false)
{
    m_CompilerSet=CompilerFactory::GetCompiler(CompilerID);
}

qtwProGenerator::~qtwProGenerator()
{}

void qtwProGenerator::DoPrepareFiles()
{
    m_Files.Clear();
    int filesCount = m_Project->GetFilesCount();
    for (int i = 0; i < filesCount; ++i)
    {
        ProjectFile* pf = m_Project->GetFile(i);
        m_Files.Add(pf);
    }
}

void qtwProGenerator::DoPrepareValidTargets()
{
    m_LinkableTargets.Clear();
    int targetsCount = m_Project->GetBuildTargetsCount();
    for (int x = 0; x < targetsCount; ++x)
    {
        ProjectBuildTarget* target = m_Project->GetBuildTarget(x);
        if (!target)
            continue;

        // create link target only if it has at least one linkable file
        bool hasFiles = false;
        int filesCount = m_Files.GetCount();
        for (int i = 0; i < filesCount; ++i)
        {
            ProjectFile* pf = m_Files[i];
            if (pf->link && pf->buildTargets.Index(target->GetTitle()) >= 0)
            {
                hasFiles = true;
                break;
            }
        }
        if (hasFiles)
            m_LinkableTargets.Add(target);
    }
}

void qtwProGenerator::UpdateCompiler(ProjectBuildTarget* target)
{
    wxString compID = target
                      ? target->GetCompilerID()
                      : (m_Project ? m_Project->GetCompilerID() : _T(""));
    if (!compID.IsEmpty())
        m_CompilerSet = CompilerFactory::GetCompiler(compID);
    else
        m_CompilerSet = CompilerFactory::GetDefaultCompiler();
}

bool qtwProGenerator::IsTargetValid(ProjectBuildTarget* target)
{
    UpdateCompiler(target);
    if (!m_CompilerSet || !target)
        return false;
    bool hasBin = target->GetTargetType() != ttCommandsOnly; // is not "commands-only" target
    bool hasCmds = !target->GetCommandsAfterBuild().IsEmpty() ||
                   !target->GetCommandsBeforeBuild().IsEmpty();
    return hasBin && (hasCmds || m_LinkableTargets.Index(target) != -1);
}

void qtwProGenerator::QuoteStringIfNeeded(wxString& str, bool force)
{
    if (!force && m_GeneratingPro)
        return;
    if (m_CompilerSet->GetSwitches().forceCompilerUseQuotes ||
            m_CompilerSet->GetSwitches().forceLinkerUseQuotes ||
            (str.Find(' ') != -1 && str.GetChar(0) != '"'))
    {
        str = _T('"') + str + _T('"');
    }
}

void qtwProGenerator::PrependHeader(wxString &buffer)
{
    wxString temp_buffer;
    temp_buffer << _T("######################################################") << _T('\n');
    temp_buffer << _T("# QMake .pro file for makefile generation") << _T('\n');
    temp_buffer << _T("# Generated by CodeBlocks IDE") << _T('\n');
    temp_buffer << _T("######################################################") << _T('\n');
    temp_buffer << _T('\n');
    buffer.Prepend(temp_buffer);
}

void qtwProGenerator::AddOrReplace(wxString &buffer, wxString Identifier, wxString args, wxString delim, bool forceReplace)
{
    bool log = false;
    wxString CBElement;
    wxStringTokenizer ProjectElements(buffer,_T("\r\n"),wxTOKEN_STRTOK);

    args.Trim(true);
    args.Trim(false);

    while (ProjectElements.HasMoreTokens())
    {
        wxString Element = ProjectElements.GetNextToken();
        if (Element.Contains(_T("#Code::Blocks Identifier - START")))
        {
            log = true;
            continue;
        }
        if (log && Element.Contains(_T("#Code::Blocks Identifier - END")))
        {
            if (CBElement.StartsWith(Identifier))
            {
                if (args.IsEmpty())
                {
                    if (forceReplace)
                    {
                        wxString buffer2Remove = _T("\n#Code::Blocks Identifier - START\n");
                        buffer2Remove << CBElement;
                        buffer2Remove << _T("#Code::Blocks Identifier - END\n");
                        buffer.Replace(buffer2Remove,_T(""));
                    }
                }
                else
                {
                    if (forceReplace)
                    {
                        wxString newElement = Identifier + delim + _T("\t") + args + _T('\n');
                        buffer.Replace(CBElement,newElement);
                    }
                    else
                    {
                        //NOTE (yop#1#): Works only with single line
                        // To add more lines support if needed, we should break at
                        // \n,\r,\\ and spaces
                        wxStringTokenizer Argumets(args,_T(" "),wxTOKEN_STRTOK);
                        wxString newElement = CBElement;
                        while (Argumets.HasMoreTokens())
                        {
                            wxString Argument = Argumets.GetNextToken();
                            if (!newElement.Contains(Argument))
                            {
                                newElement.RemoveLast(); // NOTE what if crlf after a user edit?
                                newElement << _T(' ') + Argument + _T('\n');
                            }
                        }
                        buffer.Replace(CBElement,newElement);
                    }
                }
                return;
            }
            log = false;
            CBElement = _T("");
            continue;
        }
        if (log)
            CBElement << Element << _T('\n');
    }
    //We didn't find the element so we'll add it
    if (!args.IsEmpty())
    {
        buffer << _T("\n#Code::Blocks Identifier - START\n");
        buffer << Identifier + delim + _T('\t') + args + _T('\n');
        buffer << _T("#Code::Blocks Identifier - END\n");
    }
}

void qtwProGenerator::Remove(wxString &buffer, wxString Identifier, wxString args)
{
    bool log = false;
    wxString CBElement;

    wxStringTokenizer ProjectElements(buffer,_T("\r\n"),wxTOKEN_STRTOK);
    while (ProjectElements.HasMoreTokens())
    {
        wxString Element = ProjectElements.GetNextToken();
        if (Element.Contains(_T("#Code::Blocks Identifier - START")))
        {
            log = true;
            continue;
        }
        if (log && Element.Contains(_T("#Code::Blocks Identifier - END")))
        {
            if (CBElement.StartsWith(Identifier))
            {
                wxStringTokenizer Argumets(args,_T(" "),wxTOKEN_STRTOK);
                wxString newElement = CBElement;
                while (Argumets.HasMoreTokens())
                {
                    wxString Argument = Argumets.GetNextToken();
                    if (newElement.Contains(Argument))
                    {
                        newElement.Replace(wxString(_T(" "))+Argument,_T(""));
                        newElement.Replace(Argument,_T(""));
                    }
                }
                buffer.Replace(CBElement,newElement);
                return;
            }
            log = false;
            CBElement = _T("");
            continue;
        }
        if (log)
            CBElement << Element << _T('\n');
    }
}

wxString qtwProGenerator::GetArgsFor(const wxString &buffer, wxString Identifier)
{
    bool log = false;
    wxString CBElement;

    wxStringTokenizer ProjectElements(buffer,
                                      _T("\r\n"),
                                      wxTOKEN_STRTOK);
    while ( ProjectElements.HasMoreTokens() )
    {
        wxString Element = ProjectElements.GetNextToken();
        if (Element.Contains(_T("#Code::Blocks Identifier - START")))
        {
            log = true;
            continue;
        }
        if (log && Element.Contains(_T("#Code::Blocks Identifier - END")))
        {
            if (CBElement.StartsWith(Identifier))
            {
                return CBElement;
            }
            log = false;
            CBElement = _T("");
            continue;
        }
        if (log)
            CBElement << Element << _T('\n');

    }
    return _T("");
}

void qtwProGenerator::DoAddCommonVariables(wxString& buffer, ProjectBuildTarget* target)
{
    if (!IsTargetValid(target))
        return;
    if (!m_CompilerSet)
        return;

    if (GetArgsFor(buffer,_T("CONFIG")).Contains(_T("plugin")))
    {
        AddOrReplace(buffer,_T("TEMPLATE"),_T("lib"),_T("="));
        Remove(buffer,_T("CONFIG"),_T("staticlib"));
        Remove(buffer,_T("CONFIG"),_T("dll"));
    }
    else
    {
        switch (target->GetTargetType())
        {
        case ttExecutable :
#ifdef __WXMSW__

            m_Configuration << _T("windows ");
#endif

            AddOrReplace(buffer,_T("TEMPLATE"),_T("app"),_T("="));
            break;
        case ttConsoleOnly :
            m_Configuration << _T("console ");
            AddOrReplace(buffer,_T("TEMPLATE"),_T("app"),_T("="));
            break;
        case ttStaticLib :
            m_Configuration << _T("staticlib ");
            AddOrReplace(buffer,_T("TEMPLATE"),_T("lib"),_T("="));
            break;
        case ttDynamicLib :
            m_Configuration << _T("dll ");
            AddOrReplace(buffer,_T("TEMPLATE"),_T("lib"),_T("="));
            break;
        case ttCommandsOnly :
            break;
        }
    }

    wxString thePath = m_Project->GetBasePath();
    thePath << target->GetObjectOutput();
    QuoteStringIfNeeded(thePath);
    AddOrReplace(buffer,_T("OBJECTS_DIR"),thePath,_T("="));

    wxFileName out(target->GetOutputFilename());
    thePath = m_Project->GetBasePath();
    thePath << out.GetPath(wxPATH_GET_VOLUME);
    QuoteStringIfNeeded(thePath);
    AddOrReplace(buffer,_T("DESTDIR"),thePath,_T("="));
    AddOrReplace(buffer,_T("TARGET"),out.GetName(),_T("="));
}

wxString qtwProGenerator::MkspecToUse()
{
    wxString MkspecString;
    wxString QtBaseDirString;

    wxGetEnv(_T("QMAKESPEC"),&MkspecString); // Not present in every installation
    if (!wxGetEnv(_T("QTDIR"),&QtBaseDirString))
    {
        // Not a good Qt installation ;)
        return wxString(_T(""));
    }

    if (!m_Project)
        return wxString(_T(""));

    Compiler* compilerSet = CompilerFactory::GetCompiler(m_Project->GetCompilerID());

    //qmkspecs are generally labeled using the compiler executable filenames
    wxFileName CPPCompilerFilename(compilerSet->GetPrograms().CPP);
    wxFileName CCompilerFilename(compilerSet->GetPrograms().C);

    //QMAKESPEC envinroment variable holds the default mkspec variable
    wxString CPPCompilerFileString = CPPCompilerFilename.GetName().Lower();
    wxString CCompilerFileString = CCompilerFilename.GetName().Lower();

#ifdef __WXMSW__

    MkspecString.Replace(_T("win32-"),_T(""));
#else
#ifdef __APPLE__

    MkspecString.Replace(_T("macx-"),_T(""));
#else

    struct utsname unixname;
    if (uname (&unixname) < 0)
    {
        return wxString(_T(""));
    }
    wxString OSString = wxString(unixname.sysname, wxConvUTF8).Lower();
    OSString << _T("-");
    MkspecString.Replace(OSString,_T(""));//TODO(yop#5#):check on other than Linux, Solaris
#endif
#endif

    if (CPPCompilerFileString.Contains(MkspecString.Lower()))
        return wxString(_T("")); //no need to use other than QMAKESPEC
    if (CCompilerFileString.Contains(MkspecString.Lower()))
        return wxString(_T("")); //no need to use other than QMAKESPEC

    // Oh well if we're here the envinroment's QMAKESPEC isn't good for this
    // compiler, so we'll try to find the correct one for the given compiler
    // get the names of all the available mkspecs
    wxArrayString mkspecsArray;
    MkSpecBrowser browser(mkspecsArray);

    wxDir QtMkspecDir(QtBaseDirString + wxFileName::GetPathSeparator() + wxString(_T("mkspecs")));
    QtMkspecDir.Traverse(browser);

    // Available mkspecs are in mkspecsArray
    for (unsigned int index = 0; index < mkspecsArray.GetCount(); index++)
    {
        MkspecString = mkspecsArray[index];
        MkspecString.Remove(0,QtMkspecDir.GetName().Length()+1);
        mkspecsArray[index] = MkspecString; // A little hack :)

#ifdef __WXMSW__

        MkspecString.Replace(_T("win32-"),_T(""));
#else
#ifdef __APPLE__

        MkspecString.Replace(_T("macx-"),_T(""));
#else

        MkspecString.Replace(OSString,_T(""));//TODO(yop#5#):check on other than Linux, Solaris
#endif
#endif

        if (CPPCompilerFileString.Contains(MkspecString.Lower()))
        {
            //Bingo!
            return mkspecsArray[index];
        }
        else if (CCompilerFileString.Contains(MkspecString.Lower()))
        {
            //Bingo!
            return mkspecsArray[index];
        }
    }
    // If all of the above fail the user should have the correct QMAKESPEC
    // set as an enval, else it will compile compile using the default compiler
    // or won't compile at all.
    return wxString(_T(""));
}

void qtwProGenerator::DoAppendCompilerOptions(wxString& cmd, ProjectBuildTarget* target, bool useGlobalOptions)
{
    wxArrayString opts;
    if (!m_CompilerSet)
        return;
    if (useGlobalOptions)
        opts = m_CompilerSet->GetCompilerOptions();
    else
    {
        if (target)
            opts = target->GetCompilerOptions();
        else
            opts = m_Project ? m_Project->GetCompilerOptions() : m_CompilerSet->GetCompilerOptions();
    }

    for (unsigned int x = 0; x < opts.GetCount(); ++x)
    {
        if (!m_GeneratingPro)
            Manager::Get()->GetMacrosManager()->ReplaceEnvVars(opts[x]);
        cmd << _T(" ") << opts[x];
    }
}

void qtwProGenerator::DoAppendLinkerOptions(wxString& cmd, ProjectBuildTarget* target, bool useGlobalOptions)
{
    CompileOptionsBase* obj;
    if (!m_CompilerSet)
        return;
    if (useGlobalOptions)
        obj = m_CompilerSet;
    else
        obj = target ? (CompileOptionsBase*)target : (m_Project ? (CompileOptionsBase*)m_Project : m_CompilerSet);

    wxArrayString opts = obj->GetLinkerOptions();
    for (unsigned int x = 0; x < opts.GetCount(); ++x)
    {
        if (!m_GeneratingPro)
            Manager::Get()->GetMacrosManager()->ReplaceEnvVars(opts[x]);
        cmd << _T(" ") << opts[x];
    }
}

void qtwProGenerator::DoAppendLinkerLibs(wxString& cmd, ProjectBuildTarget* target, bool useGlobalOptions)
{
    if (!m_CompilerSet)
        return;

    wxArrayString libs;
    if (useGlobalOptions)
        libs = m_CompilerSet->GetLinkLibs();
    else
    {
        if (target)
            libs = target->GetLinkLibs();
        else
        {
            if (m_Project)
                libs = m_Project->GetLinkLibs();
            else
                m_CompilerSet->GetLinkLibs();
        }
        wxString compID = target ? target->GetCompilerID() : (m_Project ? m_Project->GetCompilerID() : CompilerFactory::GetDefaultCompilerID());
        m_CompilerSet = CompilerFactory::GetCompiler(compID);
    }

    for (unsigned int x = 0; x < libs.GetCount(); ++x)
    {
        if (libs[x].IsEmpty())
            continue;

        // construct linker option for each lib, based on compiler's settings
        wxString libPrefix = m_CompilerSet->GetSwitches().libPrefix;
        wxString libExt = m_CompilerSet->GetSwitches().libExtension;
        wxString lib = libs[x];
        QuoteStringIfNeeded(lib);
        // run replacements on libs only if no slashes in name (which means it's a relative or absolute path)
        if (lib.Find('/') == -1 && lib.Find('\\') == -1)
        {
            // 'lib' prefix
            bool hadLibPrefix = false;
            if (!m_CompilerSet->GetSwitches().linkerNeedsLibPrefix &&
                    !libPrefix.IsEmpty() &&
                    lib.StartsWith(libPrefix))
            {
                lib.Remove(0, libPrefix.Length());
                hadLibPrefix = true;
            }
            // extension
            if (!m_CompilerSet->GetSwitches().linkerNeedsLibExtension &&
                    lib.Length() > libExt.Length() &&
                    lib.Right(libExt.Length() + 1) == _T(".") + libExt)
            {
                // remove the extension only if we had a lib prefix
                if (hadLibPrefix)
                    lib.RemoveLast(libExt.Length() + 1);
            }
            else if (m_CompilerSet->GetSwitches().linkerNeedsLibExtension &&
                     !libExt.IsEmpty())
            {
                if (lib.Length() <= libExt.Length() ||
                        lib.Right(libExt.Length() + 1) != _T(".") + libExt)
                {
                    lib << _T(".") << libExt;
                }
            }
            lib = m_CompilerSet->GetSwitches().linkLibs + lib;
        }
        if (!m_GeneratingPro)
            Manager::Get()->GetMacrosManager()->ReplaceEnvVars(lib);
        cmd << _T(" ") << lib;
    }
}

void qtwProGenerator::DoAppendIncludeDirs(wxString& cmd, ProjectBuildTarget* target, const wxString& prefix, bool useGlobalOptions)
{
    wxArrayString opts;
    if (!m_CompilerSet)
        return;
    if (useGlobalOptions)
        opts = m_CompilerSet->GetIncludeDirs();
    else
    {
        if (target)
            opts = target->GetIncludeDirs();
        else
            opts = m_Project ? m_Project->GetIncludeDirs() : m_CompilerSet->GetIncludeDirs();
    }

    for (unsigned int x = 0; x < opts.GetCount(); ++x)
    {
        if (opts[x].IsEmpty())
            continue;
        wxString out = UnixFilename(opts[x]);
        if (!m_GeneratingPro)
            Manager::Get()->GetMacrosManager()->ReplaceEnvVars(out);
        QuoteStringIfNeeded(out);
        cmd << _T(" ") << prefix << out;
    }
}

void qtwProGenerator::DoAppendResourceIncludeDirs(wxString& cmd, ProjectBuildTarget* target, const wxString& prefix, bool useGlobalOptions)
{
    wxArrayString opts;
    if (!m_CompilerSet)
        return;
    if (useGlobalOptions)
        opts = m_CompilerSet->GetResourceIncludeDirs();
    else
    {
        if (target)
            opts = target->GetResourceIncludeDirs();
        else
            opts = m_Project ? m_Project->GetResourceIncludeDirs() : m_CompilerSet->GetResourceIncludeDirs();
    }

    for (unsigned int x = 0; x < opts.GetCount(); ++x)
    {
        if (opts[x].IsEmpty())
            continue;
        wxString out = UnixFilename(opts[x]);
        if (!m_GeneratingPro)
            Manager::Get()->GetMacrosManager()->ReplaceEnvVars(out);
        QuoteStringIfNeeded(out);
        cmd << _T(" ") << prefix << out;
    }
}

void qtwProGenerator::DoAppendLibDirs(wxString& cmd, ProjectBuildTarget* target, const wxString& prefix, bool useGlobalOptions)
{
    wxArrayString opts;
    if (!m_CompilerSet)
        return;
    if (useGlobalOptions)
        opts = m_CompilerSet->GetLibDirs();
    else
    {
        if (target)
            opts = target->GetLibDirs();
        else
            opts = m_Project ? m_Project->GetLibDirs() : m_CompilerSet->GetLibDirs();
    }

    for (unsigned int x = 0; x < opts.GetCount(); ++x)
    {
        if (opts[x].IsEmpty())
            continue;
        wxString out = UnixFilename(opts[x]);
        if (!m_GeneratingPro)
            Manager::Get()->GetMacrosManager()->ReplaceEnvVars(out);
        QuoteStringIfNeeded(out);
        cmd << _T(" ") << prefix << out;
    }
}

void qtwProGenerator::DoAddProOptions(wxString& buffer,ProjectBuildTarget* target)
{
    UpdateCompiler(target);
    if (!m_CompilerSet)
        return;

    OptionsRelation relation = target->GetOptionRelation(ortCompilerOptions);

    wxString tempBuffer;
    DoAppendCompilerOptions(tempBuffer, 0L, true);
    if (relation==orUseTargetOptionsOnly)
    {
        DoAppendCompilerOptions(tempBuffer, target);
    }
    else if (relation==orUseParentOptionsOnly)
    {
        DoAppendCompilerOptions(tempBuffer, 0L);
    }
    else if (relation==orPrependToParentOptions)
    {
        DoAppendCompilerOptions(tempBuffer, target);
        DoAppendCompilerOptions(tempBuffer, 0L);
    }
    else if (relation==orAppendToParentOptions)
    {
        DoAppendCompilerOptions(tempBuffer, 0L);
        DoAppendCompilerOptions(tempBuffer, target);
    }
    AddOrReplace(buffer,_T("QMAKE_CXXFLAGS"),tempBuffer,_T("+="));

    tempBuffer = _T("");
    DoAppendLinkerOptions(tempBuffer, 0L, true);
    if (relation==orUseTargetOptionsOnly)
    {
        DoAppendLinkerOptions(tempBuffer, target);
    }
    else if (relation==orUseParentOptionsOnly)
    {
        DoAppendLinkerOptions(tempBuffer, 0L);
    }
    else if (relation==orPrependToParentOptions)
    {
        DoAppendLinkerOptions(tempBuffer, target);
        DoAppendLinkerOptions(tempBuffer, 0L);
    }
    else if (relation==orAppendToParentOptions)
    {
        DoAppendLinkerOptions(tempBuffer, 0L);
        DoAppendLinkerOptions(tempBuffer, target);
    }
    AddOrReplace(buffer,_T("QMAKE_LFLAGS"),tempBuffer,_T("+="));

    tempBuffer = _T("");
    DoAppendIncludeDirs(tempBuffer, 0L, _T(""), true);
    if (relation==orUseTargetOptionsOnly)
    {
        DoAppendIncludeDirs(tempBuffer, target, _T(""));
    }
    else if (relation==orUseParentOptionsOnly)
    {
        DoAppendIncludeDirs(tempBuffer, 0L, _T(""));
    }
    else if (relation==orPrependToParentOptions)
    {
        DoAppendIncludeDirs(tempBuffer, target, _T(""));
        DoAppendIncludeDirs(tempBuffer, 0L, _T(""));
    }
    else if (relation==orAppendToParentOptions)
    {
        DoAppendIncludeDirs(tempBuffer, 0L, _T(""));
        DoAppendIncludeDirs(tempBuffer, target, _T(""));
    }
    AddOrReplace(buffer,_T("INCLUDEPATH"),tempBuffer,_T("+="));

    tempBuffer = _T("");
    DoAppendLibDirs(tempBuffer, 0L, _T(""), true);
    if (relation==orUseTargetOptionsOnly)
    {
        DoAppendLibDirs(tempBuffer, target, _T(""));
    }
    else if (relation==orUseParentOptionsOnly)
    {
        DoAppendLibDirs(tempBuffer, 0L, _T(""));
    }
    else if (relation==orPrependToParentOptions)
    {
        DoAppendLibDirs(tempBuffer, target, _T(""));
        DoAppendLibDirs(tempBuffer, 0L, _T(""));
    }
    else if (relation==orAppendToParentOptions)
    {
        DoAppendLibDirs(tempBuffer, 0L, _T(""));
        DoAppendLibDirs(tempBuffer, target, _T(""));
    }
    AddOrReplace(buffer,_T("QMAKE_LIBDIR"),tempBuffer,_T("+="));

    tempBuffer = _T("");
    DoAppendLinkerLibs(tempBuffer, 0L, true);
    if (relation==orUseTargetOptionsOnly)
    {
        DoAppendLinkerLibs(tempBuffer, target);
    }
    else if (relation==orUseParentOptionsOnly)
    {
        DoAppendLinkerLibs(tempBuffer, 0L);
    }
    else if (relation==orPrependToParentOptions)
    {
        DoAppendLinkerLibs(tempBuffer, target);
        DoAppendLinkerLibs(tempBuffer, 0L);
    }
    else if (relation==orAppendToParentOptions)
    {
        DoAppendLinkerLibs(tempBuffer, 0L);
        DoAppendLinkerLibs(tempBuffer, target);
    }
    AddOrReplace(buffer,_T("LIBS"),tempBuffer,_T("+="));
}

void qtwProGenerator::DoAddTargetFiles(wxString& buffer, ProjectBuildTarget* target)
{
    if (!IsTargetValid(target))
        return;
    if (!m_CompilerSet)
        return;

    wxString target_headers;
    wxString target_sources;
    wxString target_forms;
    wxString target_resources;
    wxString target_translations;
    wxString target_pch;

    int filesCount = m_Files.GetCount();
    for (int i = 0; i < filesCount; ++i)
    {
        ProjectFile* pf = m_Files[i];
        // if the file belongs in this target
        if (pf->buildTargets.Index(target->GetTitle()) >= 0)
        {
            wxString fname;
            if (wxFile::Exists(pf->file.GetFullName()))
                // The project file is in the target dir
                fname = pf->file.GetFullName();
            else
                // We only have the info on the relative file name
                // to the project dir. And for once more we need a path
                // for the target
                // TODO(yop#5#) Find the relative filename to the target dir
                fname << m_Project->GetBasePath() << pf->relativeFilename;
            if (FileTypeOf(fname) == ftSource)
            {
                target_sources << fname << _T(" \n");
            }
            else if (FileTypeOf(fname) == ftHeader)
            {
                target_headers << fname << _T(" \n");
                if (pf->compile)
                {
                    target_pch << fname << _T(" \n");
                }
            }
            else if (fname.AfterLast(_T('.')).Lower() == _T("ui"))
            {
                target_forms << fname << _T(" \n");
                m_Configuration << _T("uic designer uitools ");
            }
            else if (fname.AfterLast(_T('.')).Lower() == _T("ts"))
            {
                target_translations << fname << _T(" \n");
            }
            else if (fname.AfterLast(_T('.')).Lower() == _T("qrc"))
            {
                target_resources << fname << _T(" \n");
                m_Configuration << _T("resources ");
            }
        }
    }

    target_headers.RemoveLast();
    target_sources.RemoveLast();
    target_forms.RemoveLast();
    target_translations.RemoveLast();
    target_resources.RemoveLast();
    target_pch.RemoveLast();

    target_headers.Replace(_T(" \n"),_T(" \\\n\t\t"));
    target_sources.Replace(_T(" \n"),_T(" \\\n\t\t"));
    target_forms.Replace(_T(" \n"),_T(" \\\n\t\t"));
    target_translations.Replace(_T(" \n"),_T(" \\\n\t\t"));
    target_resources.Replace(_T(" \n"),_T(" \\\n\t\t"));
    target_pch.Replace(_T(" \n"),_T(" \\\n\t\t"));

    AddOrReplace(buffer,_T("HEADERS"),target_headers,_T("="));
    AddOrReplace(buffer,_T("SOURCES"),target_sources,_T("="));
    AddOrReplace(buffer,_T("FORMS"),target_forms,_T("="));
    AddOrReplace(buffer,_T("RESOURCES"),target_resources,_T("+="));
    AddOrReplace(buffer,_T("TRANSLATIONS"),target_translations,_T("="));
    AddOrReplace(buffer,_T("PRECOMPILED_HEADER"),target_translations,_T("="));
}

void qtwProGenerator::DoAddSubdirToProjectPro(wxString &buffer,wxString &TargetDir)
{
    buffer << _T(" \\\n\t\t") << TargetDir;
}

void qtwProGenerator::DoPrependSubdirsConfiguration(wxString &buffer)
{
    wxString temp_buffer;
    temp_buffer << _T("######################################################") << _T('\n');
    temp_buffer << _T("# QMake .pro file for makefile generation") << _T('\n');
    temp_buffer << _T("# Generated by CodeBlocks IDE") << _T('\n');
    temp_buffer << _T("# Project:          ") << m_Project->GetTitle() << _T('\n');
    temp_buffer << _T("######################################################") << _T('\n');
    temp_buffer << _T('\n');
    temp_buffer <<  _T("TEMPLATE =") << _T('\t') << _T("subdirs") << _T('\n');

    wxArrayString virtuals = m_Project->GetVirtualBuildTargets();
    size_t virtualsCount = virtuals.GetCount();
    if (virtualsCount)
    {
        for (size_t i=0; i<virtualsCount; i++)
        {
            temp_buffer << virtuals[i];
            temp_buffer << _T(" {\n");
            temp_buffer <<  _T("SUBDIRS =");
            wxArrayString contents = m_Project->GetVirtualBuildTargetGroup(virtuals[i]);
            size_t contentsSize = contents.GetCount();
            for (size_t j=0; j<contentsSize; j++)
            {
                if (j)
                    temp_buffer << _T(" \\\n");
                temp_buffer << contents[j];
            }
            temp_buffer << _T("\n}\n");
        }
        temp_buffer << _T("else {\nSUBDIRS =");
        buffer.Remove(0,4);
        buffer.Prepend(temp_buffer);
        buffer << _T("\n}");
    }
    else
    {
        temp_buffer <<  _T("SUBDIRS =");
        buffer.Remove(0,4);
        buffer.Prepend(temp_buffer);
    }
}

void qtwProGenerator::DoAddConfiguration(wxString &buffer,ProjectBuildTarget* target)
{
    // Second argument not needed (for now at least...)
    Remove(buffer,_T("CONFIG"),_T("foo"));// Undo the little hack
    AddOrReplace(buffer,_T("CONFIG"),m_Configuration,_T("+="),false);
}

bool qtwProGenerator::CreatePro()
{
    m_GeneratingPro = true;

    DoPrepareFiles();
    DoPrepareValidTargets();

    wxString ProjectProBuffer;
    wxString TargetProBuffer;

    // Spaces should not be used in the .pro filename,
    // but I shouldn't do this behind the scenes...
    wxString ProjectProFilenameString = m_Project->GetTitle();
    ProjectProFilenameString << _T(".pro");
    m_Arguments->Append(ProjectProFilenameString);

    // The compiler choice is project wide. Inform the user if
    // different selection between the targets.
    wxString MkSpecString = MkspecToUse();
    if (!MkSpecString.IsEmpty())
    {
        // Compiler choice is different than the default one
        m_Arguments->Append(_T(" -spec "));
        m_Arguments->Append(MkSpecString);
    }

    int targetsCount = m_Project->GetBuildTargetsCount();
    for (int i = 0; i < targetsCount; ++i)
    {
        wxSetWorkingDirectory(m_Project->GetBasePath());
        ProjectBuildTarget* target = m_Project->GetBuildTarget(i);
        TargetProBuffer = _T("");
        m_Configuration = _T("");

        if (!IsTargetValid(target))
            continue;
        // No spaces in the pro filename (not good must handle this earlier and differently)
        wxString TargetProFilenameString = target->GetTitle();

        if (targetsCount==1)
        {
            // Only one target
            if (wxDir::Exists(TargetProFilenameString))
            {
                // The user is using a dir with the
                // target name (qt friendly)
                DoAddSubdirToProjectPro(ProjectProBuffer,TargetProFilenameString);
                wxSetWorkingDirectory(m_Project->GetBasePath() +
                                      TargetProFilenameString);
                TargetProFilenameString << _T(".pro");
            }
            else
            {
                // The user is using the project dir
                // for the sources of the target
                TargetProFilenameString = ProjectProFilenameString;
            }
        }
        else
        {
            //Here's the tricky stuff. More than one targets
            if (!wxDir::Exists(TargetProFilenameString))
            {
                // The user is using a custom directory structure for
                // his project. He can use the code::blocks given functionality
                // like a workspace with multiple projects etc to achieve that.
                // If I try to guess the structure then I'm playing with fire...
                return false;//TODO(yop#1#): Is any kind of cleaning up needed?
            }
            DoAddSubdirToProjectPro(ProjectProBuffer,TargetProFilenameString);
            wxSetWorkingDirectory(m_Project->GetBasePath() +
                                  TargetProFilenameString);
            TargetProFilenameString << _T(".pro");
        }

        bool needsHeader = true;
        if (wxFile::Exists(TargetProFilenameString))
        {
            needsHeader = false;
            wxFile file(TargetProFilenameString, wxFile::read);
            cbRead(file,TargetProBuffer);
        }

        if (needsHeader)
        {
            PrependHeader(TargetProBuffer);
            AddOrReplace(TargetProBuffer,_T("CONFIG"),_T("foo"),_T("+="),false); // I just want to prepend the config entry
        }
        DoAddCommonVariables(TargetProBuffer,target);
        DoAddTargetFiles(TargetProBuffer,target);
        DoAddProOptions(TargetProBuffer,target);
        DoAddConfiguration(TargetProBuffer,target);

        Manager::Get()->GetMacrosManager()->ReplaceMacros(TargetProBuffer, true);

        wxFile file(TargetProFilenameString, wxFile::write);
        cbWrite(file,TargetProBuffer);
    }

    wxSetWorkingDirectory(m_Project->GetBasePath());
    if (!ProjectProBuffer.IsEmpty())
    {
        // Subdirs
        DoPrependSubdirsConfiguration(ProjectProBuffer);
        wxFile file(ProjectProFilenameString, wxFile::write);
        cbWrite(file,ProjectProBuffer);
    }

    m_GeneratingPro = false;
    return true;
}
